/*!
* vue-maplibre-gl v3.0.3
* (c) 2023 Volker Nauruhn
* @license MIT
*/
var ve = Object.defineProperty;
var he = (e, t, r) => t in e ? ve(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var L = (e, t, r) => (he(e, typeof t != "symbol" ? t + "" : t, r), r);
import { reactive as ie, defineComponent as p, markRaw as ue, getCurrentInstance as B, shallowRef as oe, ref as G, provide as R, watch as m, toRef as v, onMounted as pe, onBeforeUnmount as P, h as T, unref as te, nextTick as ne, inject as s, createCommentVNode as E, Teleport as me, warn as _, createTextVNode as ce } from "vue";
import { Map as Se, AttributionControl as be, FullscreenControl as Le, GeolocateControl as Ae, NavigationControl as Re, ScaleControl as Oe, Marker as Ee } from "maplibre-gl";
import Ie from "mitt";
const A = Symbol("map"), w = Symbol("isLoaded"), j = Symbol("isInitialized"), M = Symbol("componentId"), N = Symbol("sourceId"), U = Symbol("sourceLayerRegistry"), le = Symbol("emitter");
function vt(e) {
  return Object.keys(e);
}
function Y(e) {
  return Object.keys(e);
}
const d = ie({
  style: "https://demotiles.maplibre.org/style.json",
  center: Object.freeze([0, 0]),
  zoom: 1,
  trackResize: !1
});
class z {
  static createEventHandler(t, r, o, a) {
    return (i = {}) => o.emit(a, { type: i.type, map: r, component: t, event: i });
  }
}
L(z, "MAP_OPTION_KEYS", [
  "antialias",
  "attributionControl",
  "bearing",
  "bearingSnap",
  "bounds",
  "boxZoom",
  "center",
  "clickTolerance",
  "collectResourceTiming",
  "crossSourceCollisions",
  "container",
  "customAttribution",
  "dragPan",
  "dragRotate",
  "doubleClickZoom",
  "hash",
  "fadeDuration",
  "failIfMajorPerformanceCaveat",
  "fitBoundsOptions",
  "interactive",
  "keyboard",
  "locale",
  "localIdeographFontFamily",
  "logoPosition",
  "maxBounds",
  "maxPitch",
  "maxZoom",
  "minPitch",
  "minZoom",
  "preserveDrawingBuffer",
  "pitch",
  "pitchWithRotate",
  "refreshExpiredTiles",
  "renderWorldCopies",
  "scrollZoom",
  "mapStyle",
  "trackResize",
  "transformRequest",
  "touchZoomRotate",
  "touchPitch",
  "zoom",
  "maxTileCacheSize",
  "pixelRatio",
  "cooperativeGestures"
]), L(z, "MARKER_OPTION_KEYS", [
  "element",
  "offset",
  "anchor",
  "color",
  "draggable",
  "clickTolerance",
  "rotation",
  "rotationAlignment",
  "pitchAlignment",
  "scale"
]), L(z, "MAP_EVENT_TYPES", [
  "error",
  "load",
  "idle",
  "remove",
  "render",
  "resize",
  "webglcontextlost",
  "webglcontextrestored",
  "dataloading",
  "data",
  "tiledataloading",
  "sourcedataloading",
  "styledataloading",
  "sourcedata",
  "styledata",
  "boxzoomcancel",
  "boxzoomstart",
  "boxzoomend",
  "touchcancel",
  "touchmove",
  "touchend",
  "touchstart",
  "click",
  "contextmenu",
  "dblclick",
  "mousemove",
  "mouseup",
  "mousedown",
  "mouseout",
  "mouseover",
  "movestart",
  "move",
  "moveend",
  "zoomstart",
  "zoom",
  "zoomend",
  "rotatestart",
  "rotate",
  "rotateend",
  "dragstart",
  "drag",
  "dragend",
  "pitchstart",
  "pitch",
  "pitchend",
  "wheel"
]);
var Z = /* @__PURE__ */ ((e) => (e.TOP_LEFT = "top-left", e.TOP_RIGHT = "top-right", e.BOTTOM_LEFT = "bottom-left", e.BOTTOM_RIGHT = "bottom-right", e))(Z || {});
const k = Object.values(Z), X = /* @__PURE__ */ new Map(), ge = Symbol("default");
function ht(e = ge) {
  let t = X.get(e);
  return t || (t = ie({ isLoaded: !1, isMounted: !1, language: null }), X.set(e, t)), t;
}
function Me(e, t, r = ge) {
  var a;
  let o = X.get(r);
  return o || (o = ie({ isLoaded: !1, isMounted: !1, language: null }), X.set(r, o)), o.isLoaded = !1, o.isMounted = !1, o.component = e, o.map = t.value, o.isLoaded = ((a = t.value) == null ? void 0 : a.loaded()) || !1, o;
}
function Ne(e, t = 250, r = !1) {
  let o;
  function a() {
    const i = arguments, l = () => {
      o = void 0, r !== !0 && e.apply(this, i);
    };
    clearTimeout(o), r === !0 && o === void 0 && e.apply(this, i), o = window.setTimeout(l, t);
  }
  return a.cancel = () => {
    clearTimeout(o);
  }, a;
}
const fe = {
  /**
   * AUTO mode uses the language of the browser
   */
  AUTO: "auto",
  /**
   * STYLE is a custom flag to keep the language of the map as defined into the style.
   * If STYLE is set in the constructor, then further modification of the language
   * with `.setLanguage()` is not possible.
   */
  STYLE_LOCK: "style_lock",
  /**
   * Default fallback languages that uses latin charaters
   */
  LATIN: "latin",
  /**
   * Default fallback languages that uses non-latin charaters
   */
  NON_LATIN: "nonlatin",
  /**
   * Labels are in their local language, when available
   */
  LOCAL: "",
  ALBANIAN: "sq",
  AMHARIC: "am",
  ARABIC: "ar",
  ARMENIAN: "hy",
  AZERBAIJANI: "az",
  BASQUE: "eu",
  BELORUSSIAN: "be",
  BOSNIAN: "bs",
  BRETON: "br",
  BULGARIAN: "bg",
  CATALAN: "ca",
  CHINESE: "zh",
  CORSICAN: "co",
  CROATIAN: "hr",
  CZECH: "cs",
  DANISH: "da",
  DUTCH: "nl",
  ENGLISH: "en",
  ESPERANTO: "eo",
  ESTONIAN: "et",
  FINNISH: "fi",
  FRENCH: "fr",
  FRISIAN: "fy",
  GEORGIAN: "ka",
  GERMAN: "de",
  GREEK: "el",
  HEBREW: "he",
  HINDI: "hi",
  HUNGARIAN: "hu",
  ICELANDIC: "is",
  INDONESIAN: "id",
  IRISH: "ga",
  ITALIAN: "it",
  JAPANESE: "ja",
  JAPANESE_HIRAGANA: "ja-Hira",
  JAPANESE_KANA: "ja_kana",
  JAPANESE_LATIN: "ja_rm",
  JAPANESE_2018: "ja-Latn",
  KANNADA: "kn",
  KAZAKH: "kk",
  KOREAN: "ko",
  KOREAN_LATIN: "ko-Latn",
  KURDISH: "ku",
  ROMAN_LATIN: "la",
  LATVIAN: "lv",
  LITHUANIAN: "lt",
  LUXEMBOURGISH: "lb",
  MACEDONIAN: "mk",
  MALAYALAM: "ml",
  MALTESE: "mt",
  NORWEGIAN: "no",
  OCCITAN: "oc",
  POLISH: "pl",
  PORTUGUESE: "pt",
  ROMANIAN: "ro",
  ROMANSH: "rm",
  RUSSIAN: "ru",
  SCOTTISH_GAELIC: "gd",
  SERBIAN_CYRILLIC: "sr",
  SERBIAN_LATIN: "sr-Latn",
  SLOVAK: "sk",
  SLOVENE: "sl",
  SPANISH: "es",
  SWEDISH: "sv",
  TAMIL: "ta",
  TELUGU: "te",
  THAI: "th",
  TURKISH: "tr",
  UKRAINIAN: "uk",
  WELSH: "cy"
};
new Set(Object.values(fe));
new Set(Object.values(fe));
function ae(e, t) {
  const r = e.getStyle().layers, o = /^\s*{\s*name\s*(:\s*(\S*))?\s*}$/, a = /^\s*name\s*(:\s*(\S*))?\s*$/, i = /^\s*{\s*name\s*(:\s*(\S*))?\s*}(\s*){\s*name\s*(:\s*(\S*))?\s*}$/, l = /^(.*)({\s*name\s*(:\s*(\S*))?\s*})(.*)$/, y = t ? `name:${t}` : "name", c = [
    "case",
    ["has", y],
    ["get", y],
    ["get", "name"]
  ];
  for (let I = 0; I < r.length; I += 1) {
    const S = r[I], H = S.layout;
    if (!H || !H["text-field"])
      continue;
    const h = e.getLayoutProperty(S.id, "text-field");
    let C;
    if (Array.isArray(h) && h.length >= 2 && h[0].trim().toLowerCase() === "concat") {
      const b = h.slice();
      for (let g = 0; g < h.length; g += 1) {
        const n = h[g];
        if ((typeof n == "string" || n instanceof String) && o.exec(n.toString())) {
          b[g] = c;
          break;
        } else if (Array.isArray(n) && n.length >= 2 && n[0].trim().toLowerCase() === "get" && a.exec(n[1].toString())) {
          b[g] = c;
          break;
        } else if (Array.isArray(n) && n.length === 4 && n[0].trim().toLowerCase() === "case") {
          b[g] = c;
          break;
        }
      }
      e.setLayoutProperty(S.id, "text-field", b);
    } else if (Array.isArray(h) && h.length >= 2 && h[0].trim().toLowerCase() === "get" && a.exec(h[1].toString())) {
      const b = c;
      e.setLayoutProperty(S.id, "text-field", b);
    } else if ((typeof h == "string" || h instanceof String) && o.exec(h.toString())) {
      const b = c;
      e.setLayoutProperty(S.id, "text-field", b);
    } else if (Array.isArray(h) && h.length === 4 && h[0].trim().toLowerCase() === "case") {
      const b = c;
      e.setLayoutProperty(S.id, "text-field", b);
    } else if ((typeof h == "string" || h instanceof String) && (C = i.exec(h.toString())) !== null) {
      const b = `{${y}}${C[3]}{name${C[4] || ""}}`;
      e.setLayoutProperty(S.id, "text-field", b);
    } else if ((typeof h == "string" || h instanceof String) && (C = l.exec(h.toString())) !== null) {
      const b = `${C[1]}{${y}}${C[5]}`;
      e.setLayoutProperty(S.id, "text-field", b);
    }
  }
}
const Ce = /* @__PURE__ */ p({
  name: "MglMap",
  props: {
    width: { type: [Number, String], default: "100%" },
    height: { type: [Number, String], default: "100%" },
    antialias: { type: Boolean, default: () => d.antialias },
    attributionControl: { type: Boolean, default: () => d.attributionControl },
    bearing: { type: Number, default: () => d.bearing },
    bearingSnap: { type: Number, default: () => d.bearingSnap },
    bounds: { type: [Array, Object], default: () => d.bounds },
    boxZoom: { type: Boolean, default: () => d.boxZoom },
    center: { type: [Array, Object], default: () => d.center },
    clickTolerance: { type: Number, default: () => d.clickTolerance },
    collectResourceTiming: { type: Boolean, default: () => d.collectResourceTiming },
    crossSourceCollisions: { type: Boolean, default: () => d.crossSourceCollisions },
    customAttribution: { type: [String, Array], default: () => d.customAttribution },
    dragPan: { type: Boolean, default: () => d.dragPan },
    dragRotate: { type: Boolean, default: () => d.dragRotate },
    doubleClickZoom: { type: Boolean, default: () => d.doubleClickZoom },
    hash: { type: [Boolean, String], default: () => d.hash },
    fadeDuration: { type: Number, default: () => d.fadeDuration },
    failIfMajorPerformanceCaveat: { type: Boolean, default: () => d.failIfMajorPerformanceCaveat },
    fitBoundsOptions: { type: Object, default: () => d.fitBoundsOptions },
    interactive: { type: Boolean, default: () => d.interactive },
    keyboard: { type: Boolean, default: () => d.keyboard },
    locale: { type: Object, default: () => d.locale },
    language: { type: String, default: () => d.language || null },
    localIdeographFontFamily: { type: String, default: () => d.localIdeographFontFamily },
    logoPosition: {
      type: [String],
      validator: (e) => e in Z,
      default: () => d.logoPosition
    },
    maxBounds: { type: [Array, Object], default: () => d.maxBounds },
    maxPitch: { type: Number, default: () => d.maxPitch },
    maxZoom: { type: Number, default: () => d.maxZoom },
    minPitch: { type: Number, default: () => d.minPitch },
    minZoom: { type: Number, default: () => d.minZoom },
    preserveDrawingBuffer: { type: Boolean, default: () => d.preserveDrawingBuffer },
    pitch: { type: Number, default: () => d.pitch },
    pitchWithRotate: { type: Boolean, default: () => d.pitchWithRotate },
    refreshExpiredTiles: { type: Boolean, default: () => d.refreshExpiredTiles },
    renderWorldCopies: { type: Boolean, default: () => d.renderWorldCopies },
    scrollZoom: { type: Boolean, default: () => d.scrollZoom },
    // StyleSpecification triggers TS7056, so users must handle typings themselves
    mapStyle: { type: [String, Object], default: () => d.style },
    trackResize: { type: Boolean, default: () => d.trackResize },
    transformRequest: { type: Function, default: d.transformRequest },
    touchZoomRotate: { type: Boolean, default: () => d.touchZoomRotate },
    touchPitch: { type: Boolean, default: () => d.touchPitch },
    zoom: { type: Number, default: () => d.zoom },
    maxTileCacheSize: { type: Number, default: () => d.maxTileCacheSize },
    mapKey: { type: [String, Symbol] },
    pixelRatio: { type: Number, default: () => d.pixelRatio },
    cooperativeGestures: { type: [Boolean, Object], default: () => d.cooperativeGestures }
  },
  emits: [
    "map:error",
    "map:load",
    "map:idle",
    "map:remove",
    "map:render",
    "map:resize",
    "map:webglcontextlost",
    "map:webglcontextrestored",
    "map:dataloading",
    "map:data",
    "map:tiledataloading",
    "map:sourcedataloading",
    "map:styledataloading",
    "map:sourcedata",
    "map:styledata",
    "map:boxzoomcancel",
    "map:boxzoomstart",
    "map:boxzoomend",
    "map:touchcancel",
    "map:touchmove",
    "map:touchend",
    "map:touchstart",
    "map:click",
    "map:contextmenu",
    "map:dblclick",
    "map:mousemove",
    "map:mouseup",
    "map:mousedown",
    "map:mouseout",
    "map:mouseover",
    "map:movestart",
    "map:move",
    "map:moveend",
    "map:zoomstart",
    "map:zoom",
    "map:zoomend",
    "map:rotatestart",
    "map:rotate",
    "map:rotateend",
    "map:dragstart",
    "map:drag",
    "map:dragend",
    "map:pitchstart",
    "map:pitch",
    "map:pitchend",
    "map:wheel"
  ],
  slots: Object,
  setup(e, t) {
    const r = ue(B()), o = oe(), a = oe(), i = G(!1), l = G(!1), y = G(!1), c = /* @__PURE__ */ new Map(), I = Ie(), S = Me(r, a, e.mapKey);
    let H;
    R(A, a), R(w, l), R(j, i), R(M, r.uid), R(N, ""), R(le, I), m(v(e, "bearing"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setBearing(n));
    }), m(v(e, "bounds"), (n) => {
      var u;
      n && ((u = a.value) == null || u.fitBounds(n, e.fitBoundsOptions));
    }), m(v(e, "center"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setCenter(n));
    }), m(v(e, "maxBounds"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setMaxBounds(n));
    }), m(v(e, "maxPitch"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setMaxPitch(n));
    }), m(v(e, "maxZoom"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setMaxZoom(n));
    }), m(v(e, "minPitch"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setMinPitch(n));
    }), m(v(e, "minZoom"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setMinZoom(n));
    }), m(v(e, "pitch"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setPitch(n));
    }), m(v(e, "renderWorldCopies"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setRenderWorldCopies(n));
    }), m(v(e, "mapStyle"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setStyle(n));
    }), m(v(e, "transformRequest"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setTransformRequest(n));
    }), m(v(e, "zoom"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setZoom(n));
    }), m(v(e, "zoom"), (n) => {
      var u;
      n && ((u = a.value) == null || u.setZoom(n));
    }), m(v(e, "language"), (n) => {
      y.value && a.value && S.language !== (n || null) && (ae(a.value, n || ""), S.language = n || null);
    }), m(v(S, "language"), (n) => {
      y.value && a.value && ae(a.value, n || "");
    });
    function h() {
      y.value = !0, e.language ? S.language = e.language : S.language && ae(a.value, e.language || "");
    }
    function C() {
      S.isMounted = !0;
      const n = Object.keys(e).filter((u) => e[u] !== void 0 && z.MAP_OPTION_KEYS.indexOf(u) !== -1).reduce((u, F) => (u[F === "mapStyle" ? "style" : F] = te(e[F]), u), { container: o.value });
      if (a.value = ue(new Se(n)), S.map = a.value, i.value = !0, c.set("__load", () => (l.value = !0, S.isLoaded = !0)), a.value.once("styledata", h), a.value.on("load", c.get("__load")), r.vnode.props) {
        for (let u = 0, F = z.MAP_EVENT_TYPES.length; u < F; u++)
          if (r.vnode.props["onMap:" + z.MAP_EVENT_TYPES[u]]) {
            const se = z.createEventHandler(r, a.value, t, "map:" + z.MAP_EVENT_TYPES[u]);
            c.set(z.MAP_EVENT_TYPES[u], se), a.value.on(z.MAP_EVENT_TYPES[u], se);
          }
      }
      a.value.getCanvas().addEventListener("webglcontextlost", g);
    }
    async function b() {
      S.isMounted = !1, S.isLoaded = !1, l.value = !1, a.value && (a.value.getCanvas().removeEventListener("webglcontextlost", g), a.value._controls.forEach((n) => {
        a.value.removeControl(n);
      }), i.value = !1, c.forEach((n, u) => {
        a.value.off(u.startsWith("__") ? u.substring(2) : u, n);
      }), a.value.remove());
    }
    function g() {
      b(), ne(C);
    }
    return pe(() => {
      C(), a.value && (H = new ResizeObserver(Ne(a.value.resize.bind(a.value), 100)), H.observe(o.value));
    }), P(() => {
      H !== void 0 && (H.disconnect(), H = void 0), b();
    }), t.expose({ map: a }), () => T(
      "div",
      {
        class: "mgl-container",
        style: { height: e.height, width: e.width }
      },
      [
        T("div", { ref: o, class: "mgl-wrapper" }),
        i.value && t.slots.default ? t.slots.default({}) : void 0
      ]
    );
  }
});
function W(e, t, r) {
  m(e, (o) => {
    var a, i;
    o && k.indexOf(o) === -1 || ((a = t.value) != null && a.hasControl(r) && t.value.removeControl(r), (i = t.value) == null || i.addControl(r, o));
  }, { immediate: !0 });
}
const xe = /* @__PURE__ */ p({
  name: "MglAttributionControl",
  props: {
    position: {
      type: String,
      validator: (e) => k.indexOf(e) !== -1
    },
    compact: Boolean,
    customAttribution: [String, Array]
  },
  setup(e) {
    const t = s(A), r = s(j), o = new be({ compact: e.compact, customAttribution: e.customAttribution });
    W(v(e, "position"), t, o), P(() => r.value && t.value.removeControl(o));
  },
  render() {
  }
}), V = class V {
  constructor(t, r) {
    L(this, "container");
    this.isAdded = t, this.container = document.createElement("div"), this.setClasses(r);
  }
  getDefaultPosition() {
    return Z.TOP_LEFT;
  }
  onAdd() {
    return ne(() => this.isAdded.value = !0), this.container;
  }
  onRemove() {
    this.isAdded.value = !1, this.container.remove();
  }
  setClasses(t) {
    t ? (this.container.classList.remove(V.CONTROL_CLASS), this.container.classList.remove(V.CONTROL_GROUP_CLASS)) : (this.container.classList.add(V.CONTROL_CLASS), this.container.classList.add(V.CONTROL_GROUP_CLASS));
  }
};
L(V, "CONTROL_CLASS", "maplibregl-ctrl"), L(V, "CONTROL_GROUP_CLASS", "maplibregl-ctrl-group");
let Q = V;
const we = /* @__PURE__ */ p({
  name: "MglCustomControl",
  props: {
    position: {
      type: String,
      validator: (e) => k.indexOf(e) !== -1
    },
    noClasses: {
      type: Boolean,
      default: !1
    }
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(A), o = s(j), a = G(!1), i = new Q(a, e.noClasses);
    return W(v(e, "position"), r, i), m(v(e, "noClasses"), (l) => i.setClasses(l)), P(() => {
      var l;
      return o.value && ((l = r.value) == null ? void 0 : l.removeControl(i));
    }), () => {
      var l;
      return a.value ? T(
        me,
        { to: i.container },
        (l = t.default) == null ? void 0 : l.call(t, {})
      ) : E("custom-component");
    };
  }
}), Te = /* @__PURE__ */ p({
  name: "MglFullscreenControl",
  props: {
    position: {
      type: String,
      default: Z.TOP_RIGHT,
      validator: (e) => k.indexOf(e) !== -1
    },
    container: {
      type: Object,
      default: null
    }
  },
  setup(e) {
    const t = s(A), r = s(j), o = new Le({ container: e.container || void 0 });
    function a() {
      ne(() => {
        var i;
        return (i = t.value) == null ? void 0 : i.resize();
      });
    }
    o.on("fullscreenstart", a), o.on("fullscreenend", a), W(v(e, "position"), t, o), P(() => {
      var i;
      o.off("fullscreenstart", a), o.off("fullscreenend", a), r.value && ((i = t.value) == null || i.removeControl(o));
    });
  },
  render() {
  }
});
class Pe {
  constructor(t = "rgba(0,0,0,0.9)", r = 4 * window.devicePixelRatio, o = "#7cf859", a = "Monaco, Consolas, Courier, monospace", i = 60 * window.devicePixelRatio, l = 90 * window.devicePixelRatio, y = 0, c = 5 * window.devicePixelRatio, I = 100 * window.devicePixelRatio) {
    L(this, "frames", 0);
    L(this, "totalTime", 0);
    L(this, "totalFrames", 0);
    L(this, "time", null);
    L(this, "map");
    L(this, "container");
    L(this, "readOutput");
    L(this, "canvas");
    L(this, "eventHandlers", /* @__PURE__ */ new Map());
    this.background = t, this.barWidth = r, this.color = o, this.font = a, this.graphHeight = i, this.graphWidth = l, this.graphTop = y, this.graphRight = c, this.width = I;
  }
  getDefaultPosition() {
    return Z.TOP_RIGHT;
  }
  onAdd(t) {
    this.map = t;
    const r = this.container = document.createElement("div");
    return r.className = "maplibregl-ctrl maplibregl-ctrl-fps", r.style.backgroundColor = this.background, r.style.borderRadius = "6px", this.readOutput = document.createElement("div"), this.readOutput.style.color = this.color, this.readOutput.style.fontFamily = this.font, this.readOutput.style.padding = "0 5px 5px", this.readOutput.style.fontSize = "9px", this.readOutput.style.fontWeight = "bold", this.readOutput.textContent = "Waitingâ€¦", this.canvas = document.createElement("canvas"), this.canvas.className = "maplibregl-ctrl-canvas", this.canvas.width = this.width, this.canvas.height = this.graphHeight, this.canvas.style.cssText = `width: ${this.width / window.devicePixelRatio}px; height: ${this.graphHeight / window.devicePixelRatio}px;`, r.appendChild(this.readOutput), r.appendChild(this.canvas), this.eventHandlers.set("movestart", this.onMoveStart.bind(this)), this.eventHandlers.set("moveend", this.onMoveEnd.bind(this)), this.map.on("movestart", this.eventHandlers.get("movestart")), this.map.on("moveend", this.eventHandlers.get("moveend")), this.container;
  }
  onRemove() {
    this.map.off("movestart", this.eventHandlers.get("movestart")), this.map.off("moveend", this.eventHandlers.get("moveend")), this.eventHandlers.clear(), this.container.parentNode.removeChild(this.container), this.map = void 0;
  }
  onMoveStart() {
    this.frames = 0, this.time = performance.now(), this.eventHandlers.set("render", this.onRender.bind(this)), this.map.on("render", this.eventHandlers.get("render"));
  }
  onMoveEnd() {
    const t = performance.now();
    this.updateGraph(this.getFPS(t)), this.frames = 0, this.time = null, this.map.off("render", this.eventHandlers.get("render"));
  }
  onRender() {
    if (this.time) {
      this.frames++;
      const t = performance.now();
      t >= this.time + 1e3 && (this.updateGraph(this.getFPS(t)), this.frames = 0, this.time = performance.now());
    }
  }
  getFPS(t) {
    return this.totalTime += t - this.time, this.totalFrames += this.frames, Math.round(1e3 * this.frames / (t - this.time)) || 0;
  }
  updateGraph(t) {
    const r = this.canvas.getContext("2d"), o = Math.round(1e3 * this.totalFrames / this.totalTime) || 0, a = (this.graphHeight, this.barWidth);
    r.fillStyle = this.background, r.globalAlpha = 1, r.fillRect(0, 0, this.graphWidth, this.graphTop), r.fillStyle = this.color, this.readOutput.textContent = `${t} FPS (${o} Avg)`, r.drawImage(
      this.canvas,
      this.graphRight + a,
      this.graphTop,
      this.graphWidth - a,
      this.graphHeight,
      this.graphRight,
      this.graphTop,
      this.graphWidth - a,
      this.graphHeight
    ), r.fillRect(
      this.graphRight + this.graphWidth - a,
      this.graphTop,
      a,
      this.graphHeight
    ), r.fillStyle = this.background, r.globalAlpha = 0.75, r.fillRect(
      this.graphRight + this.graphWidth - a,
      this.graphTop,
      a,
      (1 - t / 100) * this.graphHeight
    );
  }
}
const He = /* @__PURE__ */ p({
  name: "MglFrameRateControl",
  props: {
    position: {
      type: String,
      validator: (e) => k.indexOf(e) !== -1
    },
    background: {
      type: String,
      default: "rgba(0,0,0,0.9)"
    },
    barWidth: {
      type: Number,
      default: 4 * window.devicePixelRatio
    },
    color: {
      type: String,
      default: "#7cf859"
    },
    font: {
      type: String,
      default: "Monaco, Consolas, Courier, monospace"
    },
    graphHeight: {
      type: Number,
      default: 60 * window.devicePixelRatio
    },
    graphWidth: {
      type: Number,
      default: 90 * window.devicePixelRatio
    },
    graphTop: {
      type: Number,
      default: 0
    },
    graphRight: {
      type: Number,
      default: 5 * window.devicePixelRatio
    },
    width: {
      type: Number,
      default: 100 * window.devicePixelRatio
    }
  },
  setup(e) {
    const t = s(A), r = s(j), o = new Pe(
      e.background,
      e.barWidth,
      e.color,
      e.font,
      e.graphHeight,
      e.graphWidth,
      e.graphTop,
      e.graphRight,
      e.width
    );
    W(v(e, "position"), t, o), P(() => {
      var a;
      return r.value && ((a = t.value) == null ? void 0 : a.removeControl(o));
    });
  },
  render() {
  }
}), ze = /* @__PURE__ */ p({
  name: "MglGeolocationControl",
  props: {
    position: {
      type: String,
      default: Z.TOP_RIGHT,
      validator: (e) => k.indexOf(e) !== -1
    },
    positionOptions: {
      type: Object,
      default: { enableHighAccuracy: !1, timeout: 6e3 }
    },
    fitBoundsOptions: {
      type: Object,
      default: { maxZoom: 15 }
    },
    trackUserLocation: {
      type: Boolean,
      default: !1
    },
    showAccuracyCircle: {
      type: Boolean,
      default: !0
    },
    showUserLocation: {
      type: Boolean,
      default: !0
    }
  },
  setup(e) {
    const t = s(A), r = s(j), o = new Ae({
      positionOptions: e.positionOptions,
      fitBoundsOptions: e.fitBoundsOptions,
      trackUserLocation: e.trackUserLocation,
      showAccuracyCircle: e.showAccuracyCircle,
      showUserLocation: e.showUserLocation
    });
    W(v(e, "position"), t, o), P(() => {
      var a;
      return r.value && ((a = t.value) == null ? void 0 : a.removeControl(o));
    });
  },
  render() {
  }
}), _e = /* @__PURE__ */ p({
  name: "MglNavigationControl",
  props: {
    position: {
      type: String,
      default: Z.TOP_RIGHT,
      validator: (e) => k.indexOf(e) !== -1
    },
    showCompass: { type: Boolean, default: !0 },
    showZoom: { type: Boolean, default: !0 },
    visualizePitch: Boolean
  },
  setup(e) {
    const t = s(A), r = s(j), o = new Re({ showCompass: e.showCompass, showZoom: e.showZoom, visualizePitch: e.visualizePitch });
    W(v(e, "position"), t, o), P(() => {
      var a;
      return r.value && ((a = t.value) == null ? void 0 : a.removeControl(o));
    });
  },
  render() {
  }
});
var ye = /* @__PURE__ */ ((e) => (e.IMPERIAL = "imperial", e.METRIC = "metric", e.NAUTICAL = "nautical", e))(ye || {});
const Be = Object.values(ye), je = /* @__PURE__ */ p({
  name: "MglScaleControl",
  props: {
    position: {
      type: String,
      validator: (e) => k.indexOf(e) !== -1
    },
    maxWidth: { type: Number, default: 100 },
    unit: {
      type: String,
      default: "metric",
      validator: (e) => Be.indexOf(e) !== -1
    }
  },
  setup(e) {
    const t = s(A), r = s(j), o = new Oe({ maxWidth: e.maxWidth, unit: e.unit });
    W(v(e, "position"), t, o), P(() => {
      var a;
      return r.value && ((a = t.value) == null ? void 0 : a.removeControl(o));
    });
  },
  render() {
  }
});
var ee = /* @__PURE__ */ ((e) => (e.DEFAULT = "default", e.TEXT = "text", e.MDI = "mdi", e.SIMPLE_ICON = "simple-icons", e))(ee || {});
const ke = Object.values(ee), J = {
  text: void 0,
  mdi: {
    size: 21,
    viewbox: "0 0 24 24"
  },
  "simple-icons": {
    size: 21,
    viewbox: "0 0 24 24"
  },
  default: {
    size: 0,
    viewbox: "0 0 0 0"
  }
}, re = /* @__PURE__ */ p({
  name: "MglButton",
  props: {
    type: {
      type: String,
      default: "default",
      validator: (e) => ke.indexOf(e) !== -1
    },
    path: {
      type: String
    },
    size: Number,
    viewbox: String
  },
  slots: Object,
  setup(e, { slots: t }) {
    !e.path && e.type !== "text" && _("property `path` must be set on MaplibreButton");
    const r = G(J[e.type] || J.default);
    return m(() => e.type, (o) => r.value = J[o] || J.default), () => {
      var o, a;
      return e.type === "text" ? T("button", { type: "button" }, (o = t.default) == null ? void 0 : o.call(t, {})) : T(
        "button",
        { type: "button", class: "maplibregl-ctrl-icon" },
        [
          T(
            "svg",
            {
              width: e.size || r.value.size,
              height: e.size || r.value.size,
              viewBox: e.viewbox || r.value.viewbox
            },
            T("path", { fill: "currentColor", d: e.path })
          ),
          (a = t.default) == null ? void 0 : a.call(t, {})
        ]
      );
    };
  }
});
function de(e) {
  return e && !!e.stopPropagation;
}
const De = /* @__PURE__ */ p({
  name: "MglStyleSwitchControl",
  props: {
    position: {
      type: String,
      validator: (e) => k.indexOf(e) !== -1
    },
    mapStyles: {
      type: Array,
      required: !0,
      default: []
    },
    modelValue: {
      type: Object
    },
    isOpen: {
      type: Boolean,
      default: void 0
    }
  },
  slots: Object,
  emits: ["update:modelValue", "update:isOpen"],
  setup(e, { emit: t, slots: r }) {
    const o = s(A), a = s(j), i = s(w), l = s(le), y = G(!1), c = G(e.isOpen === void 0 ? !1 : e.isOpen), I = oe(e.modelValue === void 0 ? e.mapStyles.length ? e.mapStyles[0] : null : e.modelValue), S = new Q(y, !1), H = b.bind(null, !1);
    function h() {
      const g = o.value.getStyle().name;
      for (let n = 0, u = e.mapStyles.length; n < u; n++)
        if (e.mapStyles[n].name === g) {
          C(e.mapStyles[n]);
          break;
        }
    }
    m(i, (g) => {
      g && h();
    }, { immediate: !0 }), o.value.on("style.load", h), document.addEventListener("click", H), W(v(e, "position"), o, S), e.modelValue !== void 0 && m(v(e, "modelValue"), (g) => {
      g !== void 0 && (I.value = g);
    }), e.isOpen !== void 0 && m(v(e, "isOpen"), (g) => {
      g !== void 0 && (c.value = g);
    }), P(() => {
      a.value && (o.value.removeControl(S), o.value.off("style.load", h)), document.removeEventListener("click", H);
    });
    function C(g) {
      var n;
      ((n = I.value) == null ? void 0 : n.name) !== g.name && (l.emit("styleSwitched", g), o.value.setStyle(g.style, { diff: !1 }), e.modelValue === void 0 && (I.value = g), t("update:modelValue", g), b(!1));
    }
    function b(g, n) {
      de(n) ? n.stopPropagation() : de(g) && g.stopPropagation(), !(e.isOpen !== void 0 && e.isOpen === g || c.value === g) && (e.isOpen === void 0 ? (c.value = typeof g == "boolean" ? g : !c.value, t("update:isOpen", c.value)) : t("update:isOpen", typeof g == "boolean" ? g : !e.isOpen));
    }
    return () => {
      if (!y.value)
        return E("style-switch-control");
      const g = {
        isOpen: c,
        toggleOpen: b,
        setStyle: C,
        mapStyles: e.mapStyles,
        currentStyle: I
      };
      return T(
        me,
        { to: S.container },
        r.default ? r.default(g) : [
          r.button ? r.button(g) : T(re, {
            type: ee.MDI,
            path: "M12,18.54L19.37,12.8L21,14.07L12,21.07L3,14.07L4.62,12.81L12,18.54M12,16L3,9L12,2L21,9L12,16M12,4.53L6.26,9L12,13.47L17.74,9L12,4.53Z",
            class: ["maplibregl-ctrl-icon maplibregl-style-switch", c.value ? "is-open" : ""],
            onClick: b.bind(null, !0)
          }),
          r.styleList ? r.styleList(g) : T(
            "div",
            { class: ["maplibregl-style-list", c.value ? "is-open" : ""] },
            e.mapStyles.map((n) => {
              var u, F;
              return n.icon ? T(re, {
                type: ee.MDI,
                path: n.icon.path,
                class: ((u = I.value) == null ? void 0 : u.name) === n.name ? "is-active" : "",
                onClick: () => C(n)
              }, ce(n.label)) : T("button", {
                type: "button",
                class: ((F = I.value) == null ? void 0 : F.name) === n.name ? "is-active" : "",
                onClick: () => C(n)
              }, ce(n.label));
            })
          )
        ]
      );
    };
  },
  // just only for code assist
  template: `
		<slot>
		<slot name="button"></slot>
		<slot name="styleList"></slot>
		</slot>
	`
}), Fe = /* @__PURE__ */ p({
  name: "MglMarker",
  props: {
    coordinates: {
      type: [Object, Array],
      required: !0
    },
    offset: [Object, Array],
    anchor: String,
    color: String,
    // draggable        : Boolean as PropType<boolean>, todo implement feature
    clickTolerance: Number,
    rotation: Number,
    rotationAlignment: String,
    pitchAlignment: String,
    scale: Number
  },
  setup(e) {
    const t = s(A), r = Object.keys(e).filter((a) => e[a] !== void 0 && z.MARKER_OPTION_KEYS.indexOf(a) !== -1).reduce((a, i) => (a[i] = te(e[i]), a), {}), o = new Ee(r);
    return o.setLngLat(e.coordinates).addTo(t.value), m(() => e.coordinates, (a) => o.setLngLat(a)), m(() => e.offset, (a) => o.setOffset(a || [0, 0])), m(() => e.pitchAlignment, (a) => o.setPitchAlignment(a || "auto")), m(() => e.rotationAlignment, (a) => o.setRotationAlignment(a || "auto")), P(o.remove.bind(o)), { marker: o };
  },
  render() {
  }
});
class $ {
  constructor() {
    L(this, "unmountHandlers", /* @__PURE__ */ new Map());
  }
  registerUnmountHandler(t, r) {
    this.unmountHandlers.set(t, r);
  }
  unregisterUnmountHandler(t) {
    this.unmountHandlers.delete(t);
  }
  unmount() {
    this.unmountHandlers.forEach((t) => t());
  }
}
const q = class q {
  static genSourceOpts(t, r, o) {
    return Object.keys(r).filter((a) => r[a] !== void 0 && o.indexOf(a) !== -1).reduce((a, i) => (a[i] = te(r[i]), a), { type: t });
  }
  static getSourceRef(t, r) {
    const o = typeof r == "string", a = String(t) + (o ? r : "");
    let i = q.REFS.get(a);
    return i || (i = G(o ? null : void 0), q.REFS.set(a, i)), i;
  }
};
L(q, "REFS", /* @__PURE__ */ new Map());
let O = q;
function K(e, t, r, o, a) {
  const i = s(A), l = s(w), y = s(le);
  function c() {
    l.value && (i.value.addSource(t.sourceId, O.genSourceOpts(r, t, o)), e.value = i.value.getSource(t.sourceId));
  }
  function I() {
    e.value = null;
  }
  return m(l, c, { immediate: !0 }), i.value.on("style.load", c), y.on("styleSwitched", I), P(() => {
    l.value && (a.unmount(), i.value.removeSource(t.sourceId)), i.value.off("style.load", c), y.off("styleSwitched", I);
  });
}
const Ve = Y({
  animate: void 0,
  canvas: void 0,
  coordinates: void 0
}), Ge = /* @__PURE__ */ p({
  name: "MglCanvasSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    coordinates: Array,
    animate: Boolean,
    canvas: [Object, String]
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "canvas", Ve, a), m(v(e, "coordinates"), (i) => {
      var l;
      i && ((l = o.value) == null || l.setCoordinates(i));
    }), () => [
      E("Canvas Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), Ue = Y({
  data: void 0,
  maxzoom: void 0,
  attribution: void 0,
  buffer: void 0,
  tolerance: void 0,
  cluster: void 0,
  clusterRadius: void 0,
  clusterMaxZoom: void 0,
  clusterMinPoints: void 0,
  clusterProperties: void 0,
  lineMetrics: void 0,
  generateId: void 0,
  promoteId: void 0,
  filter: void 0
}), Ze = /* @__PURE__ */ p({
  name: "MglGeoJsonSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    data: [Object, String],
    maxzoom: Number,
    attribution: String,
    buffer: Number,
    tolerance: Number,
    cluster: [Number, Boolean],
    clusterRadius: Number,
    clusterMaxZoom: Number,
    clusterMinPoints: Number,
    clusterProperties: Object,
    lineMetrics: Boolean,
    generateId: Boolean,
    promoteId: [Object, String],
    filter: [Array, String, Object]
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "geojson", Ue, a), m(v(e, "data"), (i) => {
      var l;
      return (l = o.value) == null ? void 0 : l.setData(i || { type: "FeatureCollection", features: [] });
    }), () => [
      E("GeoJSON Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), We = Y({
  url: void 0,
  coordinates: void 0
}), Ye = /* @__PURE__ */ p({
  name: "MglImageSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    url: String,
    coordinates: Array
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "image", We, a), m(v(e, "coordinates"), (i) => {
      var l;
      i && ((l = o.value) == null || l.setCoordinates(i));
    }), () => [
      E("Image Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), $e = Y({
  url: void 0,
  tiles: void 0,
  bounds: void 0,
  minzoom: void 0,
  maxzoom: void 0,
  tileSize: void 0,
  scheme: void 0,
  attribution: void 0,
  volatile: void 0
}), Ke = /* @__PURE__ */ p({
  name: "MglRasterSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    url: String,
    tiles: Array,
    bounds: Array,
    minzoom: Number,
    maxzoom: Number,
    tileSize: Number,
    scheme: String,
    attribution: String,
    volatile: Boolean
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "raster", $e, a), () => [
      E("Raster Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), qe = Y({
  url: void 0,
  tiles: void 0,
  bounds: void 0,
  minzoom: void 0,
  maxzoom: void 0,
  tileSize: void 0,
  attribution: void 0,
  encoding: void 0,
  volatile: void 0
}), Je = /* @__PURE__ */ p({
  name: "MglRasterDemSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    url: String,
    tiles: Array,
    bounds: Array,
    minzoom: Number,
    maxzoom: Number,
    tileSize: Number,
    attribution: String,
    encoding: String,
    volatile: Boolean
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "raster-dem", qe, a), () => [
      E("RasterDem Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), Xe = Y({
  url: void 0,
  tiles: void 0,
  bounds: void 0,
  scheme: void 0,
  minzoom: void 0,
  maxzoom: void 0,
  attribution: void 0,
  promoteId: void 0,
  volatile: void 0
}), Qe = /* @__PURE__ */ p({
  name: "MglVectorSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    url: String,
    tiles: Array,
    bounds: Array,
    scheme: String,
    minzoom: Number,
    maxzoom: Number,
    attribution: String,
    promoteId: [Object, String],
    volatile: Boolean
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "vector", Xe, a), m(v(e, "tiles"), (i) => {
      var l;
      return (l = o.value) == null ? void 0 : l.setTiles(i || []);
    }), m(v(e, "url"), (i) => {
      var l;
      return (l = o.value) == null ? void 0 : l.setUrl(i || "");
    }), () => [
      E("Vector Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), et = Y({
  urls: void 0,
  coordinates: void 0
}), tt = /* @__PURE__ */ p({
  name: "MglVideoSource",
  props: {
    sourceId: {
      type: String,
      required: !0
    },
    urls: Array,
    coordinates: Array
  },
  slots: Object,
  setup(e, { slots: t }) {
    const r = s(M), o = O.getSourceRef(r, e.sourceId), a = new $();
    return R(N, e.sourceId), R(U, a), K(o, e, "video", et, a), m(v(e, "coordinates"), (i) => {
      var l;
      i && ((l = o.value) == null || l.setCoordinates(i));
    }), () => [
      E("Video Source"),
      o.value && t.default ? t.default({}) : void 0
    ];
  }
}), x = class x {
  static genLayerOpts(t, r, o, a) {
    return Object.keys(o).filter((i) => o[i] !== void 0 && x.SOURCE_OPTS.indexOf(i) !== -1).reduce((i, l) => (i[l === "sourceLayer" ? "source-layer" : l] = te(o[l]), i), { type: r, source: o.source || a, id: t });
  }
  static registerLayerEvents(t, r, o) {
    if (o.props)
      for (let a = 0, i = x.LAYER_EVENTS.length; a < i; a++) {
        const l = "on" + x.LAYER_EVENTS[a].charAt(0).toUpperCase() + x.LAYER_EVENTS[a].substr(1);
        o.props[l] && t.on(x.LAYER_EVENTS[a], r, o.props[l]);
      }
  }
  static unregisterLayerEvents(t, r, o) {
    if (o.props)
      for (let a = 0, i = x.LAYER_EVENTS.length; a < i; a++) {
        const l = "on" + x.LAYER_EVENTS[a].charAt(0).toUpperCase() + x.LAYER_EVENTS[a].substr(1);
        o.props[l] && t.off(x.LAYER_EVENTS[a], r, o.props[l]);
      }
  }
};
L(x, "SOURCE_OPTS", [
  "metadata",
  "ref",
  "source",
  "sourceLayer",
  "minzoom",
  "maxzoom",
  "interactive",
  "filter",
  "layout",
  "paint"
]), L(x, "LAYER_EVENTS", [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
]), L(x, "SHARED", {
  props: {
    layerId: {
      type: String,
      required: !0
    },
    source: [String, Object],
    metadata: [Object, Array, String, Number],
    ref: String,
    sourceLayer: String,
    minzoom: Number,
    maxzoom: Number,
    interactive: Boolean,
    filter: Array,
    before: String
  },
  emits: [
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "mouseover",
    "mouseout",
    "contextmenu",
    "touchstart",
    "touchend",
    "touchcancel"
  ]
});
let f = x;
function D(e, t) {
  const r = s(A), o = s(w), a = s(U);
  function i() {
    o.value && (t && f.unregisterLayerEvents(r.value, e, t.vnode), r.value.getLayer(e) && r.value.removeLayer(e));
  }
  a.registerUnmountHandler(e, i), P(() => {
    a.unregisterUnmountHandler(e), i();
  });
}
const at = /* @__PURE__ */ p({
  name: "MglBackgroundLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Background Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = s(A), o = s(w), a = s(M), i = O.getSourceRef(a, e.source || t);
    return D(e.layerId), m([o, i], ([l, y]) => {
      l && (y || y === void 0) && r.value.addLayer(f.genLayerOpts(e.layerId, "background", e, t), e.before || void 0);
    }, { immediate: !0 }), () => E("Background Layer");
  }
}), ot = /* @__PURE__ */ p({
  name: "MglCircleLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Circle Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "circle", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Circle Layer");
  }
}), rt = /* @__PURE__ */ p({
  name: "MglFillLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Fill Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "fill", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Fill Layer");
  }
}), it = /* @__PURE__ */ p({
  name: "MglFillExtrusionLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Fill Extrude Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "fill-extrusion", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Fill Extrusion Layer");
  }
}), nt = /* @__PURE__ */ p({
  name: "MglHeatmapLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Heatmap Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "heatmap", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Heatmap Layer");
  }
}), lt = /* @__PURE__ */ p({
  name: "MglHillshadeLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Hillshade Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "hillshade", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Hillshade Layer");
  }
}), st = /* @__PURE__ */ p({
  name: "MglLineLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Line Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "line", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Line Layer");
  }
}), ut = /* @__PURE__ */ p({
  name: "MglRasterLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Raster Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "raster", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Raster Layer");
  }
}), ct = /* @__PURE__ */ p({
  name: "MglSymbolLayer",
  props: {
    ...f.SHARED.props,
    layout: Object,
    paint: Object
  },
  emits: [...f.SHARED.emits],
  setup(e) {
    const t = s(N);
    if (!t && !e.source) {
      _("Symbol Layer: layer must be used inside source tag or source prop must be set");
      return;
    }
    const r = B(), o = s(A), a = s(w), i = s(M), l = O.getSourceRef(i, e.source || t);
    return D(e.layerId, r), m([a, l], ([y, c]) => {
      y && (c || c === void 0) && (o.value.addLayer(f.genLayerOpts(e.layerId, "symbol", e, t), e.before || void 0), f.registerLayerEvents(o.value, e.layerId, r.vnode));
    }, { immediate: !0 }), () => E("Symbol Layer");
  }
}), dt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MglAttributionControl: xe,
  MglBackgroundLayer: at,
  MglButton: re,
  MglCanvasSource: Ge,
  MglCircleLayer: ot,
  MglCustomControl: we,
  MglFillExtrusionLayer: it,
  MglFillLayer: rt,
  MglFrameRateControl: He,
  MglFullscreenControl: Te,
  MglGeoJsonSource: Ze,
  MglGeolocationControl: ze,
  MglHeatmapLayer: nt,
  MglHillshadeLayer: lt,
  MglImageSource: Ye,
  MglLineLayer: st,
  MglMap: Ce,
  MglMarker: Fe,
  MglNavigationControl: _e,
  MglRasterDemSource: Je,
  MglRasterLayer: ut,
  MglRasterSource: Ke,
  MglScaleControl: je,
  MglStyleSwitchControl: De,
  MglSymbolLayer: ct,
  MglVectorSource: Qe,
  MglVideoSource: tt
}, Symbol.toStringTag, { value: "Module" })), pt = function(t) {
  Object.entries(dt).forEach(([r, o]) => {
    t.component(r, o);
  });
};
export {
  vt as AllOptions,
  Y as AllSourceOptions,
  xe as MglAttributionControl,
  at as MglBackgroundLayer,
  re as MglButton,
  Ge as MglCanvasSource,
  ot as MglCircleLayer,
  we as MglCustomControl,
  d as MglDefaults,
  it as MglFillExtrusionLayer,
  rt as MglFillLayer,
  He as MglFrameRateControl,
  Te as MglFullscreenControl,
  Ze as MglGeoJsonSource,
  ze as MglGeolocationControl,
  nt as MglHeatmapLayer,
  lt as MglHillshadeLayer,
  Ye as MglImageSource,
  st as MglLineLayer,
  Ce as MglMap,
  Fe as MglMarker,
  _e as MglNavigationControl,
  Je as MglRasterDemSource,
  ut as MglRasterLayer,
  Ke as MglRasterSource,
  je as MglScaleControl,
  De as MglStyleSwitchControl,
  ct as MglSymbolLayer,
  Qe as MglVectorSource,
  tt as MglVideoSource,
  Z as Position,
  M as componentIdSymbol,
  pt as default,
  le as emitterSymbol,
  j as isInitializedSymbol,
  w as isLoadedSymbol,
  A as mapSymbol,
  N as sourceIdSymbol,
  U as sourceLayerRegistry,
  D as useDisposableLayer,
  ht as useMap,
  W as usePositionWatcher,
  K as useSource
};
//# sourceMappingURL=vue-maplibre-gl.es.js.map
